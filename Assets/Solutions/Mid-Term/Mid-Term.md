# 20CYS312 - Principles of Programming Languages
![](https://img.shields.io/badge/Batch-21CYS-lightgreen) ![](https://img.shields.io/badge/UG-blue) ![](https://img.shields.io/badge/Subject-PPL-blue) <br/>
![](https://img.shields.io/badge/Lecture-2-orange) ![](https://img.shields.io/badge/Practical-3-orange) ![](https://img.shields.io/badge/Credits-3-orange)

## Mid-Term Question Paper with Solutions

#### 1. Write the \textit{type signature} of the below functions.
(a) **zip :: [a] → [b] → [(a, b)]** <br/>
(b) **filter :: (a → Bool) → [a] → [a]**

#### 2. Identify the type of the following values.
 (a) "C" -  **String or [Char]** <br/>
 (b) (85, 'Y', [True]) - **(Int, Char, [Bool])** <br/>
 (c) ["S":[]] - **[[String]] or [[[Char]]]**
   
#### 3. Write a function '_pairswap_' that swaps the elements of a list on a pair-wise basis.
Assumption: the list has an even number of elements. 
Usage Example:
 1.  \> _pairswap_ [1..6]
       [2,1,4,3,6,5]
 2.  \> _pairswap_ "ammu"
       "maum"
 3.  \> _pairswap_ []
       []

**Solution:**
```
pairswap:: [a] -> [a]
pairswap [ ] = [ ]
pairswap (x:y:xs) = y:x:pairswap(xs)
```

#### 5. Write the expression equivalent to the following list comprehension using map and/or filter.
(a) [ reverse s | s ← strs, even (length s) ] <br/>
(b) [ length word | word ← words, length word > 5 ] <br/>
(c) [ (x, y) | x ← [1..5], y ← [1..5], x + y == 6 ] <br/>
(d) [ x^2 | x ← [1..10], even x ] <br/>

**Solution:** <br/>
(a) <br/>
(b) <br/>
(c) <br/>
(d) <br/>

#### 6. Write a Haskell code to generate the below HTML file with custom _body_ and _footer_ as mentioned. 
 - body = "Mid-Term Examination"
 - footer = "19-March-2024"
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Haskell Generated HTML</title>
</head>
<body>

    <main>
        <p>Content generated by Haskell:</p>
        <div id="haskell-generated-content">
            /* body content as mentioned above */
        </div>
    </main>

    <footer>
        <p>Generated on: /* footer as mentioned above */
    </footer>
</body>
</html>
```

**Solution:**
```

```

#### 7. Implement a Queue with the isEmpty, enqueue, dequeue and front function using Haskell data type with Maybe.

**Solution:**
```
data Queue a = Queue { elements :: [a] }

-- Check if the queue is empty
isEmpty :: Queue a -> Bool
isEmpty (Queue []) = True
isEmpty _          = False

-- Enqueue an element into the queue
enqueue :: a -> Queue a -> Queue a
enqueue x (Queue xs) = Queue (xs ++ [x])

-- Dequeue an element from the queue
dequeue :: Queue a -> Maybe (a, Queue a)
dequeue (Queue [])     = Nothing
dequeue (Queue (x:xs)) = Just (x, Queue xs)

-- Dequeue an element from the queue
-- dequeue :: Queue a -> Maybe (Queue a)
-- dequeue (Queue [])     = Nothing
-- dequeue (Queue (_:xs)) = Just (Queue xs)


-- Get the front element of the queue
front :: Queue a -> Maybe a
front (Queue [])    = Nothing
front (Queue (x:_)) = Just x

main :: IO ()
main = do
    let emptyQueue = Queue ([] :: [Int])
    let queue1 = enqueue 1 emptyQueue
    let queue2 = enqueue 2 queue1

    putStrLn "Testing Queue Implementation:"
    putStrLn "Initial queue:"
    putStrLn $ "Is empty? " ++ show (isEmpty emptyQueue)
    putStrLn $ "Front element: " ++ show (front emptyQueue)
    putStrLn ""

    putStrLn "After enqueueing 1:"
    putStrLn $ "Is empty? " ++ show (isEmpty queue1)
    putStrLn $ "Front element: " ++ show (front queue1)
    putStrLn ""

    putStrLn "After enqueueing 2:"
    putStrLn $ "Is empty? " ++ show (isEmpty queue2)
    putStrLn $ "Front element: " ++ show (front queue2)
    putStrLn ""

    putStrLn "Dequeueing:"
    case dequeue queue2 of
        Just (element, newQueue) -> do
            putStrLn $ "Dequeued element: " ++ show element
            putStrLn $ "New front element: " ++ show (front newQueue)
            putStrLn $ "Is empty? " ++ show (isEmpty newQueue)
        Nothing -> putStrLn "Queue is empty"
```

#### 8. Which of the following is NOT a key characteristic of Haskell?
**Solution:** Mutable variables

#### 9. Given the following data type declaration, What does the deriving (Show) part indicate?
``` data Color = Red | Green | Blue deriving (Show). ```<br/> <br/>
**Solution:** It automatically generates a Show instance for the Color type

#### 10. Complete the following Haskell function findMax. 
```
-- Consider the following incomplete Haskell function definition for
finding the maximum element in a list
findMax :: [Int] -> Int
findMax [] = ???
findMax (x:xs) = ???
-- Your task is to complete the definition of the ’findMax’ function to correctly find and
   return the maximum element in the given list ’xs’.
-- Assumption: the list ’xs’ is not empty
```
**Solution:**
```
findMax :: [Int] \rightarrow Int
findMax [x] = x
findMax (x:xs) = max$ x (findMax xs)
```
